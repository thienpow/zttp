const std = @import("std");
const HttpMethod = @import("zttp").HttpMethod;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 3) {
        std.debug.print("Usage: {s} <routes_dir> <output_file>\n", .{args[0]});
        std.process.exit(1);
    }

    const routes_dir = args[1];
    const output_file = args[2];

    //std.debug.print("Generating routes from {s} to {s}\n", .{ routes_dir, output_file });
    try generateRoutes(allocator, routes_dir, output_file);
}

pub fn generateRoutes(allocator: std.mem.Allocator, routes_dir_path: []const u8, output_file: []const u8) !void {
    var dir = std.fs.cwd().openDir(routes_dir_path, .{ .iterate = true }) catch |err| {
        std.debug.print("Warning: Failed to open {s}: {}. Generating empty routes.\n", .{ routes_dir_path, err });
        var file = try std.fs.cwd().createFile(output_file, .{});
        defer file.close();
        try file.writeAll(
            \\// Auto-generated by routegen.zig
            \\const std = @import("std");
            \\const zttp = @import("zttp");
            \\
            \\pub const Route = zttp.Route;
            \\
            \\pub fn getRoutes(allocator: std.mem.Allocator) ![]const Route {
            \\    _ = allocator;
            \\    return &[_]Route{};
            \\}
        );
        std.debug.print("Generated empty {s}\n", .{output_file});
        return;
    };
    defer dir.close();

    var walker = try dir.walk(allocator);
    defer walker.deinit();

    const http_methods = [_]HttpMethod{
        .get,     .post,  .put,
        .delete,  .patch, .head,
        .options, .trace,
    };

    var routes = std.ArrayList(struct {
        module: []const u8,
        import_path: []const u8,
        template_path: []const u8,
        path: []const u8,
        method: HttpMethod,
        handler_name: []const u8,
    }).init(allocator);
    defer {
        for (routes.items) |r| {
            allocator.free(r.module);
            allocator.free(r.import_path);
            allocator.free(r.template_path);
            allocator.free(r.path);
            allocator.free(r.handler_name);
        }
        routes.deinit();
    }

    while (try walker.next()) |entry| {
        if (entry.kind != .file or !std.mem.endsWith(u8, entry.basename, ".zig")) continue;

        const module_name = entry.basename[0 .. entry.basename.len - 4];

        // Build route path
        var path_buf = std.ArrayList(u8).init(allocator);
        defer path_buf.deinit();
        try path_buf.append('/');

        var path_components = std.mem.splitScalar(u8, entry.path, '/');
        var components = std.ArrayList([]const u8).init(allocator);
        defer components.deinit();

        while (path_components.next()) |component| {
            if (!std.mem.eql(u8, component, "index.zig")) {
                try components.append(component);
            }
        }

        for (components.items, 0..) |component, i| {
            if (std.mem.endsWith(u8, component, ".zig")) {
                const name = component[0 .. component.len - 4];
                var buf = std.ArrayList(u8).init(allocator);
                defer buf.deinit();
                for (name) |c| {
                    try buf.append(if (c == '_') '/' else c);
                }
                try path_buf.appendSlice(buf.items);
            } else {
                try path_buf.appendSlice(component);
            }
            if (i < components.items.len - 1) {
                try path_buf.append('/');
            }
        }

        const route_path = try path_buf.toOwnedSlice();

        // Read the Zig file content to check for handler functions
        const zig_file_path = try std.fs.path.join(allocator, &[_][]const u8{ routes_dir_path, entry.path });
        defer allocator.free(zig_file_path);
        const zig_file_content = std.fs.cwd().readFileAlloc(allocator, zig_file_path, 1024 * 1024) catch |err| {
            std.debug.print("Warning: Failed to read {s}: {}. Skipping.\n", .{ zig_file_path, err });
            allocator.free(route_path);
            continue;
        };
        defer allocator.free(zig_file_content);

        for (http_methods) |method| {
            const method_str = @tagName(method);
            // Check if the handler function exists (e.g., "pub fn get(")
            const handler_signature = try std.fmt.allocPrint(allocator, "pub fn {s}(", .{method_str});
            defer allocator.free(handler_signature);
            if (std.mem.indexOf(u8, zig_file_content, handler_signature) == null) {
                continue; // Skip if handler is not found
            }

            // Create the template path (sibling .zmx file)
            var template_path_buf = std.ArrayList(u8).init(allocator);
            defer template_path_buf.deinit();
            try template_path_buf.appendSlice("src/routes/");
            try template_path_buf.appendSlice(entry.path[0 .. entry.path.len - 4]);
            try template_path_buf.appendSlice(".zmx");
            const template_path = try template_path_buf.toOwnedSlice();

            // Create the import path (routes/...)
            var import_path_buf = std.ArrayList(u8).init(allocator);
            defer import_path_buf.deinit();
            try import_path_buf.appendSlice("routes/");
            try import_path_buf.appendSlice(entry.path);
            const import_path = try import_path_buf.toOwnedSlice();

            try routes.append(.{
                .module = try allocator.dupe(u8, module_name),
                .import_path = import_path,
                .template_path = template_path,
                .path = try allocator.dupe(u8, route_path),
                .method = method,
                .handler_name = try allocator.dupe(u8, method_str),
            });
        }

        allocator.free(route_path);
    }

    var file = try std.fs.cwd().createFile(output_file, .{});
    defer file.close();

    var writer = file.writer();
    try writer.writeAll(
        \\// Auto-generated by routegen.zig
        \\const std = @import("std");
        \\const zttp = @import("zttp");
        \\
        \\pub const Route = zttp.Route;
        \\
        \\pub fn getRoutes(allocator: std.mem.Allocator) ![]const Route {
        \\    var routes = std.ArrayList(Route).init(allocator);
        \\    errdefer {
        \\        for (routes.items) |r| {
        \\            allocator.free(r.module_name);
        \\            allocator.free(r.path);
        \\            allocator.free(r.template_path);
        \\        }
        \\        routes.deinit();
        \\    }
        \\
    );

    for (routes.items) |route| {
        var buf = std.ArrayList(u8).init(allocator);
        defer buf.deinit();
        try buf.writer().writeAll(
            \\    try routes.append(Route{
            \\        .module_name = try allocator.dupe(u8, "
        );
        try buf.appendSlice(route.module);
        try buf.appendSlice(
            \\"),
            \\        .method = .
        );
        try buf.appendSlice(@tagName(route.method));
        try buf.appendSlice(
            \\,
            \\        .path = try allocator.dupe(u8, "
        );
        try buf.appendSlice(route.path);
        try buf.appendSlice(
            \\"),
            \\        .template_path = try allocator.dupe(u8, "
        );
        try buf.appendSlice(route.template_path);
        try buf.appendSlice(
            \\"),
            \\        .handler = @import("
        );
        try buf.appendSlice(route.import_path);
        try buf.appendSlice(
            \\").
        );
        try buf.appendSlice(route.handler_name);
        try buf.appendSlice(
            \\,
            \\    });
            \\
        );
        try writer.writeAll(buf.items);
    }

    try writer.writeAll(
        \\    return routes.toOwnedSlice();
        \\}
    );

    std.debug.print("Generated {s} with {} routes\n", .{ output_file, routes.items.len });
}
