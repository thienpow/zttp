const std = @import("std");
const HttpMethod = @import("zttp").HttpMethod;
const Route = @import("zttp").Route;
const Template = @import("zttp").Template;
const WebSocketHandlerFn = @import("zttp").WebSocketHandlerFn;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 3) {
        std.debug.print("Usage: {s} <routes_dir> <output_file>\n", .{args[0]});
        std.process.exit(1);
    }

    const routes_dir = args[1];
    const output_file = args[2];

    try generateRoutesAndTemplates(allocator, routes_dir, output_file);
}

pub fn generateRoutesAndTemplates(allocator: std.mem.Allocator, routes_dir_path: []const u8, output_file: []const u8) !void {
    var dir = std.fs.cwd().openDir(routes_dir_path, .{ .iterate = true }) catch |err| {
        std.debug.print("Warning: Failed to open {s}: {}. Generating empty routes and templates.\n", .{ routes_dir_path, err });
        var file = try std.fs.cwd().createFile(output_file, .{});
        defer file.close();
        try file.writeAll(
            \\// Auto-generated by routegen.zig
            \\const std = @import("std");
            \\const zttp = @import("zttp");
            \\
            \\pub const Route = zttp.Route;
            \\pub const Template = zttp.Template;
            \\
            \\pub fn getRoutes(allocator: std.mem.Allocator) ![]const Route {
            \\    _ = allocator;
            \\    return &[_]Route{};
            \\}
            \\
            \\pub fn getTemplates(allocator: std.mem.Allocator) ![]const Template {
            \\    _ = allocator;
            \\    return &[_]Template{};
            \\}
        );
        std.debug.print("Generated empty {s}\n", .{output_file});
        return;
    };
    defer dir.close();

    // First walker: Collect routes from .zig files
    var route_walker = try dir.walk(allocator);
    defer route_walker.deinit();

    const http_methods = [_]HttpMethod{
        .get,     .post,  .put,
        .delete,  .patch, .head,
        .options, .trace,
    };

    var routes = std.ArrayList(struct {
        module: []const u8,
        import_path: []const u8,
        path: []const u8,
        method: HttpMethod,
        handler_name: []const u8,
        is_websocket: bool,
    }).init(allocator);
    defer {
        for (routes.items) |r| {
            allocator.free(r.module);
            allocator.free(r.import_path);
            allocator.free(r.path);
            allocator.free(r.handler_name);
        }
        routes.deinit();
    }

    while (try route_walker.next()) |entry| {
        if (entry.kind != .file or !std.mem.endsWith(u8, entry.basename, ".zig")) continue;

        const module_name = entry.basename[0 .. entry.basename.len - 4];

        // Build route path
        var path_buf = std.ArrayList(u8).init(allocator);
        defer path_buf.deinit();
        try path_buf.append('/');

        var path_components = std.mem.splitScalar(u8, entry.path, '/');
        var components = std.ArrayList([]const u8).init(allocator);
        defer components.deinit();

        while (path_components.next()) |component| {
            if (!std.mem.eql(u8, component, "index.zig")) {
                try components.append(component);
            }
        }

        for (components.items, 0..) |component, i| {
            if (std.mem.endsWith(u8, component, ".zig")) {
                const name = component[0 .. component.len - 4];
                var buf = std.ArrayList(u8).init(allocator);
                defer buf.deinit();
                for (name) |c| {
                    try buf.append(if (c == '_') '/' else c);
                }
                try path_buf.appendSlice(buf.items);
            } else {
                try path_buf.appendSlice(component);
            }
            if (i < components.items.len - 1) {
                try path_buf.append('/');
            }
        }

        const route_path = try path_buf.toOwnedSlice();

        // Read the Zig file content to check for handler functions
        const zig_file_path = try std.fs.path.join(allocator, &[_][]const u8{ routes_dir_path, entry.path });
        defer allocator.free(zig_file_path);
        const zig_file_content = std.fs.cwd().readFileAlloc(allocator, zig_file_path, 1024 * 1024) catch |err| {
            std.debug.print("Warning: Failed to read {s}: {}. Skipping.\n", .{ zig_file_path, err });
            allocator.free(route_path);
            continue;
        };
        defer allocator.free(zig_file_content);

        // Check for HTTP handlers
        for (http_methods) |method| {
            const method_str = @tagName(method);
            const handler_signature = try std.fmt.allocPrint(allocator, "pub fn {s}(", .{method_str});
            defer allocator.free(handler_signature);
            if (std.mem.indexOf(u8, zig_file_content, handler_signature) == null) {
                continue;
            }

            // Create the import path (routes/...)
            var import_path_buf = std.ArrayList(u8).init(allocator);
            defer import_path_buf.deinit();
            try import_path_buf.appendSlice("routes/");
            try import_path_buf.appendSlice(entry.path);
            const import_path = try import_path_buf.toOwnedSlice();

            try routes.append(.{
                .module = try allocator.dupe(u8, module_name),
                .import_path = import_path,
                .path = try allocator.dupe(u8, route_path),
                .method = method,
                .handler_name = try allocator.dupe(u8, method_str),
                .is_websocket = false,
            });
        }

        // Check for WebSocket handler
        const ws_handler_signature = "pub fn ws(";
        if (std.mem.indexOf(u8, zig_file_content, ws_handler_signature) != null) {
            // Create the import path (routes/...)
            var import_path_buf = std.ArrayList(u8).init(allocator);
            defer import_path_buf.deinit();
            try import_path_buf.appendSlice("routes/");
            try import_path_buf.appendSlice(entry.path);
            const import_path = try import_path_buf.toOwnedSlice();

            try routes.append(.{
                .module = try allocator.dupe(u8, module_name),
                .import_path = import_path,
                .path = try allocator.dupe(u8, route_path),
                .method = .get, // WebSocket upgrades use GET
                .handler_name = try allocator.dupe(u8, "ws"),
                .is_websocket = true,
            });
        }

        allocator.free(route_path);
    }

    // Second walker: Collect templates from .zmx files
    var template_walker = try dir.walk(allocator);
    defer template_walker.deinit();

    var templates = std.ArrayList(struct {
        name: []const u8,
        path: []const u8,
    }).init(allocator);
    defer {
        for (templates.items) |t| {
            allocator.free(t.name);
            allocator.free(t.path);
        }
        templates.deinit();
    }

    while (try template_walker.next()) |entry| {
        if (entry.kind != .file or !std.mem.endsWith(u8, entry.basename, ".zmx")) continue;

        // Build template name (e.g., "index", "demo/conditionals/index", "profile/index")
        var name_buf = std.ArrayList(u8).init(allocator);
        defer name_buf.deinit();
        const relative_path = entry.path[0 .. entry.path.len - 4]; // Remove ".zmx"
        try name_buf.appendSlice(relative_path);
        const template_name = try name_buf.toOwnedSlice();

        // Build template path for @embedFile (e.g., "routes/index.zmx")
        const template_path = try std.fs.path.join(allocator, &[_][]const u8{ "routes", entry.path });

        try templates.append(.{
            .name = template_name,
            .path = template_path,
        });
    }

    // Generate output file
    var file = try std.fs.cwd().createFile(output_file, .{});
    defer file.close();

    var writer = file.writer();
    try writer.writeAll(
        \\// Auto-generated by routegen.zig
        \\const std = @import("std");
        \\const zttp = @import("zttp");
        \\
        \\pub const Route = zttp.Route;
        \\pub const Template = zttp.Template;
        \\
        \\pub fn getRoutes(allocator: std.mem.Allocator) ![]const Route {
        \\    var routes = std.ArrayList(Route).init(allocator);
        \\    errdefer {
        \\        for (routes.items) |r| {
        \\            allocator.free(r.module_name);
        \\            allocator.free(r.path);
        \\        }
        \\        routes.deinit();
        \\    }
        \\
    );

    for (routes.items) |route| {
        var buf = std.ArrayList(u8).init(allocator);
        defer buf.deinit();
        try buf.writer().writeAll(
            \\    try routes.append(Route{
            \\        .module_name = try allocator.dupe(u8, "
        );
        try buf.appendSlice(if (route.is_websocket) "websocket" else route.module);
        try buf.appendSlice(
            \\"),
            \\        .method = .
        );
        try buf.appendSlice(@tagName(route.method));
        try buf.appendSlice(
            \\,
            \\        .path = try allocator.dupe(u8, "
        );
        try buf.appendSlice(route.path);
        try buf.appendSlice(
            \\"),
            \\        .
        );
        try buf.appendSlice(if (route.is_websocket) "ws_handler" else "handler");
        try buf.appendSlice(
            \\ = @import("
        );
        try buf.appendSlice(route.import_path);
        try buf.appendSlice(
            \\").
        );
        try buf.appendSlice(route.handler_name);
        try buf.appendSlice(
            \\,
            \\    });
            \\
        );
        try writer.writeAll(buf.items);
    }

    try writer.writeAll(
        \\    return routes.toOwnedSlice();
        \\}
        \\
        \\pub fn getTemplates(allocator: std.mem.Allocator) ![]const Template {
        \\    var templates = std.ArrayList(Template).init(allocator);
        \\    errdefer {
        \\        for (templates.items) |t| {
        \\            allocator.free(t.name);
        \\        }
        \\        templates.deinit();
        \\    }
        \\
    );

    for (templates.items) |template| {
        var buf = std.ArrayList(u8).init(allocator);
        defer buf.deinit();
        try buf.writer().writeAll(
            \\    try templates.append(Template{
            \\        .name = try allocator.dupe(u8, "
        );
        try buf.appendSlice(template.name);
        try buf.appendSlice(
            \\"),
            \\        .buffer = @embedFile("
        );
        try buf.appendSlice(template.path);
        try buf.appendSlice(
            \\"),
            \\    });
            \\
        );
        try writer.writeAll(buf.items);
    }

    try writer.writeAll(
        \\    return templates.toOwnedSlice();
        \\}
    );

    std.debug.print("Generated {s} with {} routes and {} templates\n", .{ output_file, routes.items.len, templates.items.len });
}
