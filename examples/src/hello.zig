const std = @import("std");
const zttp = @import("zttp");
const Server = zttp.Server;
const WebSocket = zttp.WebSocket;
const ThreadPool = zttp.ThreadPool;
const chat_ws = @import("routes/demos/websocket/chat/ws.zig");

pub fn main() !void {
    // Set up allocator
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Server configuration
    const options = Server.Options{
        .port = 8088,
        .thread_pool_options = ThreadPool.Options{},
        .websocket_options = WebSocket.Options{
            .max_payload_size = 2 * 1024 * 1024,
            .read_buffer_size = 8192,
        },
    };

    // Create the server
    var bundle = try zttp.createServer(allocator, options);
    defer bundle.deinit();

    // Initialize the chat WebSocket module with the same allocator
    // This is crucial - we need to ensure the module is initialized before routes are loaded
    try chat_ws.init(allocator);
    defer chat_ws.deinit();

    // Add middleware
    try bundle.use(zttp.Middleware.static);
    try bundle.use(zttp.Middleware.htmx);

    // Add diagnostic route for testing
    //try bundle.get("/chat-status", chatStatusHandler);

    // Load routes and templates
    try bundle.loadRoutes(@import("AutoGenerated.zig").getRoutes);
    try bundle.loadTemplates(@import("AutoGenerated.zig").getTemplates);

    // Start the server
    std.log.info("Starting server on port {d}...", .{options.port});
    try bundle.start(true);
}

// Diagnostic handler to check WebSocket connection status
fn chatStatusHandler(ctx: *zttp.Context) !void {
    const info = chat_ws.getDebugInfo();
    var buf: [256]u8 = undefined;
    const response = try std.fmt.bufPrintZ(&buf, "Chat Status: {d} clients connected", .{info.clients});
    try ctx.html(response);
}
