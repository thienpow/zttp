const std = @import("std");
const HttpMethod = @import("zttp").HttpMethod;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 3) {
        std.debug.print("Usage: {s} <routes_dir> <output_file>\n", .{args[0]});
        std.process.exit(1);
    }

    const routes_dir = args[1];
    const output_file = args[2];

    std.debug.print("Generating routes from {s} to {s}\n", .{ routes_dir, output_file });
    try generateRoutes(allocator, routes_dir, output_file);
}

pub fn generateRoutes(allocator: std.mem.Allocator, routes_dir_path: []const u8, output_file: []const u8) !void {
    var dir = std.fs.cwd().openDir(routes_dir_path, .{ .iterate = true }) catch |err| {
        std.debug.print("Warning: Failed to open {s}: {}. Generating empty routes.\n", .{ routes_dir_path, err });
        var file = try std.fs.cwd().createFile(output_file, .{});
        defer file.close();
        try file.writeAll(
            \\// Auto-generated by routegen.zig
            \\const std = @import("std");
            \\const zttp = @import("zttp");
            \\
            \\pub const Route = zttp.Route;
            \\
            \\pub fn getRoutes(allocator: std.mem.Allocator) ![]const Route {
            \\    _ = allocator;
            \\    return &[_]Route{};
            \\}
        );
        std.debug.print("Generated empty {s}\n", .{output_file});
        return;
    };
    defer dir.close();

    var walker = try dir.walk(allocator);
    defer walker.deinit();

    const http_methods = [_]HttpMethod{ .get, .post };

    var routes = std.ArrayList(struct {
        module: []const u8,
        import_path: []const u8,
        path: []const u8,
        method: HttpMethod,
        handler_name: []const u8,
    }).init(allocator);
    defer {
        for (routes.items) |r| {
            allocator.free(r.module);
            allocator.free(r.import_path);
            allocator.free(r.path);
            allocator.free(r.handler_name);
        }
        routes.deinit();
    }

    while (try walker.next()) |entry| {
        if (entry.kind != .file or !std.mem.endsWith(u8, entry.basename, ".zig")) continue;

        const module_name = entry.basename[0 .. entry.basename.len - 4];

        var path_buf = std.ArrayList(u8).init(allocator);
        defer path_buf.deinit();
        try path_buf.append('/');

        var path_components = std.mem.splitScalar(u8, entry.path, '/');
        var components = std.ArrayList([]const u8).init(allocator);
        defer components.deinit();

        while (path_components.next()) |component| {
            if (!std.mem.eql(u8, component, "index.zig")) {
                try components.append(component);
            }
        }

        for (components.items, 0..) |component, i| {
            if (std.mem.endsWith(u8, component, ".zig")) {
                const name = component[0 .. component.len - 4];
                var buf = std.ArrayList(u8).init(allocator);
                defer buf.deinit();
                for (name) |c| {
                    try buf.append(if (c == '_') '/' else c);
                }
                try path_buf.appendSlice(buf.items);
            } else {
                try path_buf.appendSlice(component);
            }
            if (i < components.items.len - 1) {
                try path_buf.append('/');
            }
        }

        const route_path = try path_buf.toOwnedSlice();

        for (http_methods) |method| {
            const import_path = try allocator.dupe(u8, entry.path);
            const method_str = @tagName(method);
            try routes.append(.{
                .module = try allocator.dupe(u8, module_name),
                .import_path = import_path,
                .path = try allocator.dupe(u8, route_path),
                .method = method,
                .handler_name = try allocator.dupe(u8, method_str),
            });
            std.debug.print("Found route: {s} {s} ({s}) [import: routes/{s}]\n", .{ method_str, route_path, module_name, import_path });
        }

        allocator.free(route_path);
    }

    var file = try std.fs.cwd().createFile(output_file, .{});
    defer file.close();

    var writer = file.writer();
    try writer.writeAll(
        \\// Auto-generated by routegen.zig
        \\const std = @import("std");
        \\const zttp = @import("zttp");
        \\
        \\pub const Route = zttp.Route;
        \\
        \\pub fn getRoutes(allocator: std.mem.Allocator) ![]const Route {
        \\    var routes = std.ArrayList(Route).init(allocator);
        \\    errdefer {
        \\        for (routes.items) |r| {
        \\            allocator.free(r.module_name);
        \\            allocator.free(r.path);
        \\        }
        \\        routes.deinit();
        \\    }
        \\
    );

    for (routes.items) |route| {
        var buf = std.ArrayList(u8).init(allocator);
        defer buf.deinit();
        try buf.writer().writeAll(
            \\    if (@hasDecl(@import("routes/
        );
        try buf.appendSlice(route.import_path);
        try buf.appendSlice(
            \\"), "
        );
        try buf.appendSlice(route.handler_name);
        try buf.appendSlice(
            \\")) {
            \\        try routes.append(Route{
            \\            .module_name = try allocator.dupe(u8, "
        );
        try buf.appendSlice(route.module);
        try buf.appendSlice(
            \\"),
            \\            .method = .
        );
        try buf.appendSlice(@tagName(route.method));
        try buf.appendSlice(
            \\,
            \\            .path = try allocator.dupe(u8, "
        );
        try buf.appendSlice(route.path);
        try buf.appendSlice(
            \\"),
            \\            .handler = @import("routes/
        );
        try buf.appendSlice(route.import_path);
        try buf.appendSlice(
            \\").
        );
        try buf.appendSlice(route.handler_name);
        try buf.appendSlice(
            \\,
            \\        });
            \\    }
            \\
        );
        try writer.writeAll(buf.items);
    }

    try writer.writeAll(
        \\    return routes.toOwnedSlice();
        \\}
    );

    std.debug.print("Generated {s} with {} routes\n", .{ output_file, routes.items.len });
}
